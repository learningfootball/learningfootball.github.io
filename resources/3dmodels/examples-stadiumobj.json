{"version":"0.0.2","signiture":"webgpulab","info":"https://webgpu.xbdev.net","date":"2022-06-29T16:59:22.127Z","author":"Kenwright","uniqueid":"aLbvufnXjP7ATkh8IxkzVS1Nz44RbGfW","tasks":[{"tabname":"objloader.js","tabcontents":"console.log('objloader.js');\n\n/*\n  Single helper function that parses the obj file\n*/\n\n\n// ref: https://notebook.xbdev.net/index.php?page=obj&\nreadObj = function(txt)\n{\n    console.log('readObj...');\n\n    let objects = [];\n\n    objects.push( { 'name':'test', 'v':[], 'vt':[], 'vn':[], 'f':[], 'usemtl':'' } );\n    let data = { 'v':[], 'n':[], 'f':[] };\n\n    txt = txt.replaceAll('  ', ' ');\n    let lines = txt.split('\\n');\n    console.log('num lines:', lines.length );\n\n  \n    for (let i=0; i<lines.length; i++)\n    {\n        let line = lines[i];\n        line = line.trim()\n        if ( line.length < 2 ) continue;\n        if ( line[0] == '#'  ) continue;\n\n        let parts = line.split(' ');\n        if ( parts.length < 1 ) continue;\n\n        try{\n        switch( parts[0] )\n        {            \n            case 'v': // v 0.089624 1.419387 0.052847\n            {\n                objects.reverse()[0].v.push( parts[1] );\n                objects.reverse()[0].v.push( parts[2] );\n                objects.reverse()[0].v.push( parts[3] );\n            }\n            break;\n\n            case 'vt': // vt 0.818181 0.000000\n            {\n                objects.reverse()[0].vt.push( parts[1] );\n                objects.reverse()[0].vt.push( parts[2] );\n            }\n            break;\n\n            case 'vn': // vn 0.5499 0.7413 0.3847\n            {\n                objects.reverse()[0].vn.push( parts[1] );\n                objects.reverse()[0].vn.push( parts[2] );\n                objects.reverse()[0].vn.push( parts[3] );\n            }\n            break;\n\n            case 'f': // f 1/1/1 14/2/1 13/3/1\n            {   \n                // f v1/vt1/vn1 v2/vt2/vn2 v3/vt3/vn3 ...\n                // f v1//vn1 v2//vn2 v3//vn3 ... (double slashes)\n                    \n\n\n/*\nIf you have 4 indices, e.g.:\n\n0 1 2 3\nThe division into two triangles would be one with the first 3 indices, and one with the first, third, and fourth. In this example:\n\n0 1 2\n0 2 3\nLet's try some ASCII art to illustrate this:\n\n3-------2\n|      /|\n|    /  |\n|  /    |\n|/      |\n0-------1\n*/\n              \n                let i0 = parts[1].split('/')[0]-1;\n                let i1 = parts[2].split('/')[0]-1;\n                let i2 = parts[3].split('/')[0]-1;\n                let i3 = parts.length ==4 ? undefined : (parts[4].split('/')[0]-1);\n\n                let n0 = parts[1].split('/')[2]-1;\n                let n1 = parts[2].split('/')[2]-1;\n                let n2 = parts[3].split('/')[2]-1;\n                let n3 = parts.length ==4 ? undefined : (parts[4].split('/')[2]-1);\n\n                if ( parts[1].includes('//') )\n                {\n                    n0 = parts[1].split('//')[1]-1;\n                    n1 = parts[2].split('//')[1]-1;\n                    n2 = parts[3].split('//')[1]-1;\n                    n3 = parts.length == 4 ? undefined : (parts[4].split('//')[1]-1);\n                }\n\n                if ( i3 == undefined ) // triangles\n                {\n                  \n                    let v = []\n                    for (let g=0; g<3; g++)\n                    {\n                    let idx = [i0,i1,i2][g];\n                    let x0 = objects.reverse()[0].v[  (3* idx)+0   ];\n                    let y0 = objects.reverse()[0].v[  (3* idx)+1   ];\n                    let z0 = objects.reverse()[0].v[  (3* idx)+2   ];\n                    v.push( { x:x0, y:y0, z:z0 } );\n                    }\n                    data.v.push( v[1].x );  data.v.push( v[1].y ); data.v.push( v[1].z );\n                    data.v.push( v[0].x );  data.v.push( v[0].y ); data.v.push( v[0].z );\n                    data.v.push( v[2].x );  data.v.push( v[2].y ); data.v.push( v[2].z );\n                    data.f.push( data.f.length );\n                    data.f.push( data.f.length );\n                    data.f.push( data.f.length );\n\n                    for (let g=0; g<[n0,n1,n2].length; g++)\n                    {\n                    let nx0 = -objects.reverse()[0].vn[  3*[n0,n1,n2][g]+0   ];\n                    let ny0 = -objects.reverse()[0].vn[  3*[n0,n1,n2][g]+1   ];\n                    let nz0 = -objects.reverse()[0].vn[  3*[n0,n1,n2][g]+2   ];\n                    data.n.push( nx0 );\n                    data.n.push( ny0 );\n                    data.n.push( nz0 );\n                    }\n\n                }\n                else // quads \n                {\n                    let v = [];\n                    for (let g=0; g<4; g++)\n                    {\n                    let idx = [i0,i1,i2,i3][g];\n                    let x0 = objects.reverse()[0].v[  (3* idx)+0   ];\n                    let y0 = objects.reverse()[0].v[  (3* idx)+1   ];\n                    let z0 = objects.reverse()[0].v[  (3* idx)+2   ];\n                    v.push( { x:x0, y:y0, z:z0 } );\n                    }\n                    data.v.push( v[1].x );  data.v.push( v[1].y ); data.v.push( v[1].z );\n                    data.v.push( v[0].x );  data.v.push( v[0].y ); data.v.push( v[0].z );\n                    data.v.push( v[2].x );  data.v.push( v[2].y ); data.v.push( v[2].z );\n                    data.f.push( data.f.length );\n                    data.f.push( data.f.length );\n                    data.f.push( data.f.length );\n\n                    data.v.push( v[2].x );  data.v.push( v[2].y ); data.v.push( v[2].z );\n                    data.v.push( v[0].x );  data.v.push( v[0].y ); data.v.push( v[0].z );\n                    data.v.push( v[3].x );  data.v.push( v[3].y ); data.v.push( v[3].z );\n                    data.f.push( data.f.length );\n                    data.f.push( data.f.length );\n                    data.f.push( data.f.length );\n                    \n                    let n = [];\n                    for (let g=0; g<4; g++)\n                    {\n                    let idx = [n0,n1,n2,n3][g];\n                    let nx0 = -objects.reverse()[0].vn[  (3* idx)+0   ];\n                    let ny0 = -objects.reverse()[0].vn[  (3* idx)+1   ];\n                    let nz0 = -objects.reverse()[0].vn[  (3* idx)+2   ];\n                    n.push( { x:nx0, y:ny0, z:nz0 } );\n                    }\n                    data.n.push( n[0].x );  data.n.push( n[0].y ); data.n.push( n[0].z );\n                    data.n.push( n[1].x );  data.n.push( n[1].y ); data.n.push( n[1].z );\n                    data.n.push( n[2].x );  data.n.push( n[2].y ); data.n.push( n[2].z );\n\n                    data.n.push( n[0].x );  data.n.push( n[0].y ); data.n.push( n[0].z );\n                    data.n.push( n[2].x );  data.n.push( n[2].y ); data.n.push( n[2].z );\n                    data.n.push( n[3].x );  data.n.push( n[3].y ); data.n.push( n[3].z ); \n                }\n\n            }\n            break;\n\n      }// end switch(..)\n      \n      }catch(e){ }\n        \n        \n    }// for\n\n    return [ data ];\n}// readObj(..)\n\n\n\t \n\t "},{"tabname":"index.js","tabcontents":"console.log('index.js');\n\n/*\n    WebGPU Example \n    Simple uncluttered example (no libraries, just raw WebGPU)\n    \n    Obj 3d model loader/viewer - use a custom loader (single file/function) - as an\n    obj file can have multiple 'meshes'\n\n    Select .obj file local computer, loads the obj, parses the data and re-initializes the buffers\n    Cut down test version (just basics) - but fully functional\n*/\n\"use strict;\"\n\ndocument.body.style['height'] = '512px';\n\nlet p = document.createElement('p');\np.innerHTML = 'select .obj file (visualized/drawn using webgpu)';\ndocument.body.appendChild( p );\n\nlet input = document.createElement('input');\ndocument.body.appendChild( input );\ninput.type     = 'file';\ninput.onchange = onFileSelected;\n\nfunction onFileSelected(event)\n{\n  let selectedFile = event.target.files[0];\n  console.log( 'file:', selectedFile.name ); // somefile.obj\n\n  let reader = new FileReader();\n  reader.onload = function(event) {\n     let objtxt = event.target.result;\n     objects = readObj(objtxt);\n\n     processObjFile();\n\n     createBuffers();\n\n     updateMatrices();\n  }\n  reader.readAsText(selectedFile);\n}\n\n\n\n\n\n\n// get some model data (use json as it's easy to load/setup)\nlet response = await fetch('./var/resources/footballstadium4.obj');\nlet objtext  = await response.text();\n\nlet objects = readObj( objtext );\nlet middle  = null;\nlet dist    = null;\n\nfunction processObjFile()\n{\n  console.log( 'processObjFile... ' );\n\n  console.log('num meshes:', objects.length );\n\n  console.log('vertices:', objects[0].v.length   );\n  console.log('faces:'   , objects[0].f.length   );\n  console.log('normals:' , objects[0].n.length  );\n\n\n  // get some bounds for the model (doesn't go off screen)\n  let min = {x: 1000000, y: 1000000, z: 1000000};\n  let max = {x:-1000000, y:-1000000, z:-1000000};\n  for (let i=0; i<objects[0].v.length/3; i++)\n  {\n      min.x = Math.min( min.x, objects[0].v[i*3+0] );\n      min.y = Math.min( min.y, objects[0].v[i*3+1] );\n      min.z = Math.min( min.z, objects[0].v[i*3+2] );\n\n      max.x = Math.max( max.x, objects[0].v[i*3+0] );\n      max.y = Math.max( max.y, objects[0].v[i*3+1] );\n      max.z = Math.max( max.z, objects[0].v[i*3+2] );\n  }\n  let delta  = { x: (max.x-min.x), y:(max.y-min.y), z: (max.z-min.z) };\n  middle = { x: min.x + delta.x*0.5, y:min.y+delta.y*0.5, z:min.z+delta.z*0.5 };\n  dist   = Math.sqrt( delta.x*delta.x + delta.y*delta.y + delta.z*delta.z );\n  \n  console.log( 'model size:', dist );\n  console.log('delta:', delta );\n  console.log('min:', min.x, min.y, min.z );\n  console.log('max:', max.x, max.y, max.z );\n  console.log('middle:', middle.x, middle.y, middle.z );\n  \n\n  \n  let ss = Math.max( delta.x, Math.max( delta.y, delta.z ) );\n  console.log('normalizing data size - unit model');\n  for (let i=0; i<objects[0].v.length/3; i++)\n  {\n      objects[0].v[i*3+0] = (objects[0].v[i*3+0] - middle.x ) / ss;\n      objects[0].v[i*3+1] = (objects[0].v[i*3+1] - middle.y ) / ss + (delta.y/ss)*0.5; // sits on the ground\n      objects[0].v[i*3+2] = (objects[0].v[i*3+2] - middle.z ) / ss;\n  }\n\n}\nprocessObjFile();\n\n\nlet prom = await fetch('https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.6.0/gl-matrix-min.js');\nlet matc = await prom.text();\n\nvar script   = document.createElement('script');\nscript.type  = 'text/javascript';\nscript.async = false;\nscript.innerHTML = matc;\ndocument.head.appendChild(script); \n\nlet canvas = document.createElement('canvas');\ndocument.body.appendChild( canvas );\ncanvas.width  = canvas.height = 512;\n\nconst adapter = await navigator.gpu.requestAdapter();\nconst device  = await adapter.requestDevice();\nconst context = canvas.getContext('webgpu');\n\nconst presentationSize   = [ canvas.width,   \n                             canvas.height ] \nconst presentationFormat = context.getPreferredFormat(adapter);\n\n\n// --------------------------------------------------\nlet translateMat = mat4.create();\nlet rotateXMat   = mat4.create();\nlet rotateYMat   = mat4.create();\nlet rotateZMat   = mat4.create();\nlet scaleMat     = mat4.create();\n\nconst projectionMatrix     = mat4.create();\nconst viewMatrix           = mat4.create();\nconst modelMatrix          = mat4.create();\nconst viewProjectionMatrix = mat4.create();\nconst modelRotation        = mat4.create();\nconst rotation             = [0, 0, 0];\n\nconst uniformBuffer = device.createBuffer({\n  size: 192,  // 3 x mat4x4 = 3x64 = 192\n  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n});\n\nfunction updateMatrices()\n{\nmat4.perspective(projectionMatrix, Math.PI / 2, canvas.width / canvas.height, 0.01, 5000.0)\nmat4.lookAt(viewMatrix, [0, 0.3, 0.6],  [0, 0, 0], [0, 1, 0]);\nmat4.multiply(viewProjectionMatrix, projectionMatrix, viewMatrix);\n\ndevice.queue.writeBuffer(uniformBuffer,   64, viewProjectionMatrix );\n}\nupdateMatrices();\n\nconst sceneUniformBindGroupLayout = device.createBindGroupLayout({\n  entries: [\n    {\n      binding: 0,\n      visibility: GPUShaderStage.VERTEX,\n      buffer: {\n        type: \"uniform\"\n      }\n    }\n   ]\n});\n\n\nconst sceneUniformBindGroup = device.createBindGroup({\n  layout: sceneUniformBindGroupLayout,\n  entries: [\n    {\n      binding: 0, \n       resource: {\n        buffer: uniformBuffer\n      } \n    } \n  ]\n});\n// --------------------------------------------------\n\n\ncontext.configure({ device : device, compositingAlphaMode: \"opaque\", compositingAlphaMode: \"opaque\",\n                    format : presentationFormat,\n                    size   : presentationSize });\nconst vertWGSL = `\nstruct Uniforms {\n  modelMatrix               : mat4x4<f32>,\n  modelViewProjectionMatrix : mat4x4<f32>,\n  modelRotation             : mat4x4<f32>\n};\n@binding(0) @group(0)  var<uniform> uniforms : Uniforms;\n\nstruct VSOut {\n    @builtin(position) Position: vec4<f32>,\n    @location(0)       position: vec3<f32>,\n    @location(1)       normal  : vec3<f32>\n};\n\n@vertex\nfn main(@location(0) inPos    : vec3<f32>,\n        @location(1) normal   : vec3<f32>) -> VSOut \n{\n    var vsOut: VSOut;\n    vsOut.Position = uniforms.modelViewProjectionMatrix * uniforms.modelMatrix * vec4<f32>(inPos , 1.0);\n    vsOut.position = (uniforms.modelMatrix * vec4<f32>(inPos , 1.0)).xyz;\n\n    let n = normalize( normal );\n    let tiM = uniforms.modelRotation; // transpose( uniforms.modelRotation );\n    let fN = ( tiM  * vec4<f32>(n,0.0) ).xyz;\n\n    vsOut.normal = fN; // ( uniforms.modelMatrix * vec4<f32>(n,0.0) ).xyz;\n    return vsOut;\n}\n`;\n\nconst fragWGSL = `\n@fragment\nfn main(@location(0)  position: vec3<f32>,\n        @location(1)  normal  : vec3<f32>) -> @location(0) vec4<f32> \n{\n    //  color channels are clamped [0, 1]. \n    // (0, 0, 0) is black and (1, 1, 1) is completely white\n    // normalized vector components are in the range [-1, 1]\n    // normal facing the camera [0,0,-1] should be rgb values: [0.5,0.5,1.0]\n\n    //let normalCol = normalize(normal) * 0.5 + 0.5;\n    //return vec4<f32>(normalCol*1.0, 1.0);\n\n    //let positionCol = abs(normalize(position));\n    //return vec4<f32>(positionCol*1.0, 1.0);\n\n    let diffuse = max(0.0, dot( normal, vec3<f32>(0.0,-0.2,-1.0) ));\n    return vec4<f32>( diffuse, diffuse, diffuse, 1.0 );\n\n\n    //return vec4<f32>(1.0,0.0,0.0, 1.0);\n}\n`;\n\n\n// ------------------------------\n\nlet positions = null;\nlet normals   = null;\nlet indices   = null;\n\nvar positionBuffer = null;\nvar normalBuffer   = null;\nvar indexBuffer    = null;\n\n// put the buffer creation/update inside a function - so it can be\n// changed dynamically (after loaded/running)\nfunction createBuffers()\n{\nconsole.log('creating buffers..');\npositions = new Float32Array( objects[0].v   );\nnormals   = new Float32Array( objects[0].n  );\nindices   = new Uint32Array(  objects[0].f   );\n\n// if we don't have normals, let's use the position data\nif ( objects[0].n.length == 0 ) normals   = new Float32Array( objects[0].v );\n\n\npositionBuffer = device.createBuffer({size: ((positions.byteLength+ 3) & ~3), usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST });\nnormalBuffer   = device.createBuffer({size: ((normals.byteLength+ 3) & ~3),   usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST });\nindexBuffer    = device.createBuffer({size: ((indices.byteLength+ 3) & ~3),   usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST  });\n\n\ndevice.queue.writeBuffer(positionBuffer,  0, positions );\ndevice.queue.writeBuffer(normalBuffer,    0, normals);\ndevice.queue.writeBuffer(indexBuffer,     0, indices);\n}\ncreateBuffers();\n\n// ------------------------------\n\nconst pipeline = device.createRenderPipeline({\n  layout: device.createPipelineLayout({bindGroupLayouts: [sceneUniformBindGroupLayout]}),\n  vertex:      { module     : device.createShaderModule({code   : vertWGSL }),\n                 entryPoint : 'main',\n                 buffers    : [ { arrayStride: 12, attributes: [{ shaderLocation: 0,\n                                                                  format: \"float32x3\",\n                                                                  offset: 0  }]         },\n                                { arrayStride: 12, attributes: [{ shaderLocation: 1,\n                                                                  format: \"float32x3\",\n                                                                  offset: 0  }]         }\n    ]\n  },\n  fragment:    { module     : device.createShaderModule({ code  : fragWGSL }),\n                 entryPoint : 'main',\n                 targets    : [ {format: presentationFormat } ],\n  },\n  primitive: {\n    topology: \"triangle-list\",\n    frontFace: \"ccw\",\n    cullMode: 'none'\n  },\n  depthStencil: {\n    format: \"depth24plus\",\n    depthWriteEnabled: true,\n    depthCompare: \"less\"\n  }\n});\n\nconst texture = device.createTexture({ size        : presentationSize, \n                                       sampleCount : 1,\n                                       format      : presentationFormat,\n                                       usage       : GPUTextureUsage.RENDER_ATTACHMENT });\nconst textureView    = texture.createView();\n\n\n\nconst depthTexture = device.createTexture({\n  size: [canvas.width, canvas.height, 1],\n  format: \"depth24plus\",\n  usage:  GPUTextureUsage.RENDER_ATTACHMENT\n})\n\nconst renderPassDescription = {\n  colorAttachments: [{\n    view: textureView, //context.getCurrentTexture().createView(),\n    loadOp:'clear', clearValue: [0.0, 0.8, 0.8, 1], // clear screen \n    storeOp: 'store'\n  }],\n  depthStencilAttachment: {\n    view: depthTexture.createView(),\n    depthLoadOp:'clear', // load/clear\n    depthClearValue: 1,\n    depthStoreOp: \"discard\", // store/discard\n    //// // stencilLoadValue: 0,\n    //// // stencilStoreOp: \"store\"\n  }\n};\n\n\n\n\nfunction frame() \n{\n  function xformMatrix(xform, translate, rotate, scale, xrot) {\n    translate = translate || [0, 0, 0];\n    rotate = rotate || [0, 0, 0];\n    scale = scale || [1, 1, 1];\n\n    mat4.fromTranslation(translateMat, translate);\n    mat4.fromXRotation(rotateXMat, rotate[0]);\n    mat4.fromYRotation(rotateYMat, rotate[1]);\n    mat4.fromZRotation(rotateZMat, rotate[2]);\n    //mat4.fromScaling(scaleMat, scale);\n\n    mat4.multiply(xform, translateMat, scaleMat);\n    mat4.multiply(xform, rotateXMat, xform);\n    mat4.multiply(xform, rotateYMat, xform);\n    mat4.multiply(xform, rotateZMat, xform);\n\n    mat4.multiply(xrot, rotateXMat, scaleMat);\n    mat4.multiply(xrot, rotateYMat, xrot);\n    mat4.multiply(xrot, rotateZMat, xrot);\n  }\n\n  rotation[1] += 0.0005;\n  //rotation[0] += 0.002;\n  // let translate = [ -middle.x, -middle.y, -middle.z ];\n  let translate = [ 0, 0, 0 ];\n\n  xformMatrix(modelMatrix, translate, rotation, null, modelRotation);\n  device.queue.writeBuffer(uniformBuffer, 0,   modelMatrix);\n  device.queue.writeBuffer(uniformBuffer, 128, modelRotation);\n\n  //  ---------------------\n\n  renderPassDescription.colorAttachments[0].view = context.getCurrentTexture().createView();\n\n  //renderPassDescription.colorAttachments[0].view = texture.createView();\n\n  const commandEncoder = device.createCommandEncoder();\n  const renderPass = commandEncoder.beginRenderPass(renderPassDescription);\n\n  renderPass.setPipeline(pipeline);\n  renderPass.setVertexBuffer(0, positionBuffer);\n  renderPass.setVertexBuffer(1, normalBuffer);\n  renderPass.setIndexBuffer(indexBuffer, 'uint32');\n  renderPass.setBindGroup(0, sceneUniformBindGroup);\n  renderPass.drawIndexed( objects[0].f.length, 1 );\n  renderPass.end();\n\n  device.queue.submit([commandEncoder.finish()]);\n\n  requestAnimationFrame(frame);\n} \nframe();\n\n// more controlled updates \n//onmousemove = function() {\n  //frame();\n//}\n\nconsole.log('ready...');\n\n\n\t \n\t "}]}